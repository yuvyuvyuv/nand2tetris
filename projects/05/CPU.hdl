// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/05/CPU.hdl

/**
 * The Hack CPU (Central Processing unit), consisting of an ALU,
 * two registers named A and D, and a program counter named PC.
 * The CPU is designed to fetch and execute instructions written in 
 * the Hack machine language. 
 In particular, functions as follows:
 *  1. Executes the inputted instruction according to the Hack machine language specification. 
    2. The D and A in the language specification refer to CPU-resident registers, 
        while M refers to the external memory location addressed by A, 
        i.e. to Memory[A]. 
    3. The inM input holds the value of this location. 
        If the current instruction needs to write a value to M, 
        the value is placed in outM, 
        the address of the target location is placed in the addressM output, 
        and the writeM control bit is asserted. 
        (When writeM==0, any value may appear in outM). 
    4. The outM and writeM outputs are combinational: 
            they are affected instantaneously by the execution of the current instruction. 
        The addressM and pc outputs are clocked: 
            although they are affected by the execution of the current instruction, 
            they commit to their new values only in the next time step. 
        If reset==1 then the CPU jumps to address 0 
        (i.e. pc is set to 0 in next time step) 
        rather than to the address resulting from executing the current instruction. 
 */

CHIP CPU {

    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current
                         // program (reset==1) or continue executing
                         // the current program (reset==0).

    OUT outM[16],        // M value output
        writeM,          // Write to M? 
        addressM[15],    // Address in data memory (of M)
        pc[15];          // address of next instruction

    PARTS:
    //decoding : “ixxaccccccdddjjj”.
    DMux(in = true, sel = instruction[15],a = Aop,b = Cop);

    //left most mux
    Mux16(a = ALUout, b = instruction, sel = Aop, out = Aregin);


    // A-register - load if A is dest or Aop
    Or(a = Aop, b = instruction[5], out = Aload);
    ARegister(in = Aregin, load = Aload, out = Aregout, out[0..14] = addressM);



    //right mux - A and M register selection, AM - the c/sel input is the a-bit, instruction[12]
    Mux16(a = Aregout, b = inM, sel = instruction[12], out = AMout);



    // D-register - only load when the "d1d" part of instruction And it is an C-op
    And(a = Cop, b = instruction[4], out = Dload);
    DRegister(in = ALUout, load = Dload, out = Dregout);





    //ALU - the six paramaters inputs are the six c-bit
    ALU(x = Dregout, y = AMout, 
    zx = instruction[11], nx = instruction[10],
    zy = instruction[9], ny = instruction[8], 
    f = instruction[7], no = instruction[6],
    out = outM, out = ALUout, zr = zr, ng = ng);

    

    //to calculate the jump boolean
    Or(a = ng, b = zr, out = ngORzr);
    Not(in = ngORzr, out = pos);
    And(a = pos, b = instruction[0], out = JGT);
    And(a = zr , b = instruction[1], out = JEQ);
    And(a = ng , b = instruction[2], out = JLT);

    Or(a = JGT, b = JEQ, out = JGE);
    Or(a = JGE, b = JLT, out = JMP);

    // jump if C-op
    And(a = Cop, b = JMP, out = jump);

    //if jump then load = 1, else inc = 1
    DMux(in = true, sel = jump, a = PCinc, b = PCA);
    PC(in = Aregout, reset = reset, load = PCA, inc = PCinc, out[0..14] = pc);    



    //set writeM if dd1 and C-op
    And(a = Cop, b = instruction[3], out = writeM);
}